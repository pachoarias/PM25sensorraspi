##Disclaimer I was helped by AI to get this sensor working

Here is the complete Markdown document detailing every step we took, including the logic and necessary code modifications, ready for your GitHub repository.

-----

# üõ†Ô∏è DFRobot Gravity PM2.5 Sensor (I2C) - Raspberry Pi 4 Troubleshooting Guide

This document outlines the end-to-end process for successfully interfacing the **DFRobot Gravity: PM2.5 Air Quality Sensor** with a **Raspberry Pi 4** using the **I2C protocol**. 
This guide specifically addresses and solves common software and configuration errors encountered when using the official, but slightly outdated, DFRobot Python library file.

## 1\. ‚öôÔ∏è Hardware & Initial Configuration

### 1.1. I2C Wiring Diagram (The Correct Connection)

This sensor requires the **I2C** pins, not the UART pins.

| Sensor Cable Color | Sensor Function | $\to$ | Raspberry Pi 4 Pin | Physical Pin Number |
| :---: | :---: | :---: | :---: | :---: |
| **Red** | VCC (Power) | $\to$ | **5V Power** | Pin 4 |
| **Black** | GND (Ground) | $\to$ | **Ground** | Pin 6 |
| **Blue** (Signal) | SDA (Data) | $\to$ | **SDA** | **Pin 3** |
| **Green** (Signal) | SCL (Clock) | $\to$ | **SCL** | **Pin 5** |

**Crucial Note on Polarity:** If the sensor does not appear when running the `i2cdetect` command, physically **swap the Blue and Green wires** (Blue $\to$ Pin 5, Green $\to$ Pin 3). This corrects the manufacturer's cable color inconsistency.

### 1.2. Enable I2C and Check Sensor

1.  **Enable I2C:** Run `sudo raspi-config` $\to$ **Interface Options** $\to$ **P5 I2C** $\to$ **Yes**. Reboot the Pi.
2.  **Verify Connection:** Install `i2c-tools` (`sudo apt install i2c-tools`) and run:
    ```bash
    i2cdetect -y 1
    ```
    The address **`19`** must appear in the grid for the I2C communication to proceed.

-----

## 2\. üêç Software Setup & Dependency Fixes

Modern Raspberry Pi OS blocks system-wide `pip` installs. We must use a **virtual environment** and manually resolve library dependencies.

### 2.1. Create Environment and Install Dependencies

1.  **Setup Virtual Environment:**
    ```bash
    mkdir pm_sensor_project
    cd pm_sensor_project
    python3 -m venv venv
    source venv/bin/activate  # Activate the environment
    ```
2.  **Install Required Modules:**
    The DFRobot library has hidden dependencies on modules for I2C, SPI, and GPIO:
    ```bash
    pip install smbus2 spidev RPi.GPIO
    ```

### 2.2. Get the DFRobot Library File

Since the library is not on PyPI, download the official Python file into your project directory:

1.  Download the raw content from this URL and save it as **`dfrobot_airqualitysensor.py`**:
    `https://github.com/DFRobot/DFRobot_AirQualitySensor/blob/master/python/raspberrypi/dfrobot_airqualitysensor.py`

### 2.3. Resolve Library Errors (Manual Edits)

The downloaded file must be edited to fix four critical issues that lead to **`ModuleNotFoundError`** and **`AttributeError`**.

Open the file for editing: `nano dfrobot_airqualitysensor.py`

| Error Resolved | Location/Code | Fix Applied |
| :--- | :--- | :--- |
| **`ModuleNotFoundError: smbus`** | Near Line 13: `import smbus` | Change to `import smbus2 as smbus` |
| **`NameError: name 'I2C_MODE' is not defined`** | Near Line 18: Add after imports | Add: `I2C_MODE = 0` and `UART_MODE = 1` |
| **`AttributeError: begin`** | New Function | Add `def set_active_mode(self):` (See below) |
| **Sensor stuck at 0** | New Function | Add `set_active_mode` which sends `0x01` to command register `0x01` |

**Add the `set_active_mode()` function (Critical Fix):**

Add this method within the `DFRobot_AirQualitySensor` class definition:

```python
    # Fix 4: Force Active Mode command (resolves persistent zero readings)
    def set_active_mode(self):
        '''
          @brief Set sensor to continuous reporting (Active) mode.
          @note This is the essential command to kick the sensor out of Query Mode.
        '''
        mode = [0x01] 
        self.write_reg(0x01,mode)
```

-----

## 3\. üíª The Final Python Script (`air_sensor.py`)

This script incorporates the new `set_active_mode()` call and the correct Pythonic function names (`gain_version` instead of `gainVersion`).

Save this code as **`air_sensor.py`** in your project directory:

```python
import time
import sys
# Import smbus2 for I2C
from smbus2 import SMBus
# Import the corrected DFRobot class from the local file
from dfrobot_airqualitysensor import DFRobot_AirQualitySensor 

# --- I2C/Sensor Constants ---
I2C_ADDRESS = 0x19
I2C_BUS_NUMBER = 1 

# Function constants for the DFRobot class
PARTICLE_PM1_0_STANDARD = 0
PARTICLE_PM2_5_STANDARD = 1
PARTICLE_PM10_STANDARD  = 2

# Initialize Sensor Object (DFRobot class handles bus initialization now)
particle = DFRobot_AirQualitySensor(I2C_BUS_NUMBER, I2C_ADDRESS) 


def setup():
    print("Initializing sensor via I2C...")
    
    # Use the custom function to set the sensor to continuous reporting
    try:
        particle.set_active_mode() 
        print("Sensor set to Active Mode.")
    except Exception as e:
        print(f"I2C Communication Error during setup: {e}")
        sys.exit()

    # The gain_version() call confirms communication is working
    # Note: Method name is gain_version, not gainVersion
    version = particle.gain_version()  
    print(f"Sensor Firmware Version: {version}")

    print("Sensor setup complete! Reading data...")
    time.sleep(5) 


def loop():
    while True:
        try:
            # Use the corrected Python method names (lowercase/underscores)
            PM2_5 = particle.gain_particle_concentration_ugm3(PARTICLE_PM2_5_STANDARD)
            PM1_0 = particle.gain_particle_concentration_ugm3(PARTICLE_PM1_0_STANDARD)
            PM10 = particle.gain_particle_concentration_ugm3(PARTICLE_PM10_STANDARD)
            
            print("\n--- Air Quality Reading (ug/m3) ---")
            print(f"PM2.5 concentration: {PM2_5}")
            print(f"PM1.0 concentration: {PM1_0}")
            print(f"PM10 concentration: {PM10}")
            print("-" * 35)

        except Exception as e:
            print(f"Error reading sensor data: {e}. Retrying...")
            
        time.sleep(2)

if __name__ == "__main__":
    try:
        setup()
        loop()
    except KeyboardInterrupt:
        print("\nProgram terminated by user.")
        sys.exit()
```

### 4\. Run the Program

Execute the script from your terminal (ensure virtual environment is active):

```bash
python air_sensor.py
```
